from fastapi import APIRouter, Depends, HTTPException, status
from typing import List # Removed Dict as db_jobs is gone
from uuid import UUID # Removed uuid4 as DB generates it
import datetime

from app.schemas.job_schemas import JobApplicationCreate, JobApplicationRead, JobApplicationUpdate
from app.schemas.auth_schemas import UserResponse
from app.api.deps import get_current_user
from app.services.supabase_client import supabase_client # Import the initialized client

router = APIRouter()

@router.post("/", response_model=JobApplicationRead, status_code=status.HTTP_201_CREATED)
async def create_job_application(
    job_in: JobApplicationCreate,
    current_user: UserResponse = Depends(get_current_user)
):
    if supabase_client is None:
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Supabase client not available")

    user_id = UUID(current_user.id) # Ensure user_id is UUID if current_user.id is string

    # Prepare data for Supabase. `user_id` is crucial for RLS.
    # Supabase client handles `created_at` and `updated_at` if table defaults are set.
    # `id` will be generated by the database (DEFAULT gen_random_uuid()).
    job_data_to_insert = job_in.dict()
    job_data_to_insert['user_id'] = str(user_id) # Supabase client might prefer string for UUIDs
    if job_data_to_insert.get('deadline') is not None: # Ensure date is in ISO format string for DB
        job_data_to_insert['deadline'] = job_data_to_insert['deadline'].isoformat()


    try:
        response = supabase_client.table("job_applications").insert(job_data_to_insert).execute()
        if response.data:
            created_job_data = response.data[0]
            # Ensure all fields for JobApplicationRead are present or handled
            # Supabase returns created_at, updated_at, and id from the DB
            return JobApplicationRead(**created_job_data)
        else:
            # Handle potential errors from Supabase if data is empty but no exception was raised
            # This case might indicate an issue with RLS or the insert operation itself
            error_detail = "Failed to create job application: No data returned from database."
            if hasattr(response, 'error') and response.error:
                error_detail = f"Failed to create job application: {response.error.message}"
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=error_detail)

    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Database error: {str(e)}")


@router.get("/", response_model=List[JobApplicationRead])
async def read_job_applications(
    current_user: UserResponse = Depends(get_current_user),
    skip: int = 0, # Supabase range() can be used for pagination
    limit: int = 100
):
    if supabase_client is None:
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Supabase client not available")

    user_id = str(current_user.id) # Use string representation of UUID for Supabase filter

    try:
        # RLS should handle filtering by user_id automatically if set up correctly.
        # Explicitly filtering by user_id here is a good practice for clarity and security belt-and-suspenders.
        response = supabase_client.table("job_applications").select("*").eq("user_id", user_id).range(skip, skip + limit -1).execute()
        if response.data:
            return [JobApplicationRead(**job) for job in response.data]
        return [] # Return empty list if no data
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Database error: {str(e)}")

@router.get("/{job_id}", response_model=JobApplicationRead)
async def read_job_application(
    job_id: UUID,
    current_user: UserResponse = Depends(get_current_user)
):
    if supabase_client is None:
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Supabase client not available")

    user_id = str(current_user.id)

    try:
        response = supabase_client.table("job_applications").select("*").eq("id", str(job_id)).eq("user_id", user_id).maybe_single().execute()

        if response.data:
            return JobApplicationRead(**response.data)
        else:
            # If RLS is working, an attempt to access another user's job would also result in no data.
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Job application not found or access denied")
    except Exception as e:
        # Catch generic errors, e.g. if job_id is not a valid UUID format for DB
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Database error: {str(e)}")


@router.put("/{job_id}", response_model=JobApplicationRead)
async def update_job_application(
    job_id: UUID,
    job_in: JobApplicationUpdate,
    current_user: UserResponse = Depends(get_current_user)
):
    if supabase_client is None:
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Supabase client not available")

    user_id = str(current_user.id)
    update_data = job_in.dict(exclude_unset=True)

    if not update_data:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="No fields to update")

    if 'deadline' in update_data and update_data['deadline'] is not None:
        update_data['deadline'] = update_data['deadline'].isoformat()

    # Supabase automatically updates 'updated_at' if using "now()" as default in table schema.
    # If not, you might need to add it manually: update_data['updated_at'] = datetime.datetime.now(datetime.timezone.utc).isoformat()

    try:
        # First, verify the job exists and belongs to the user by trying to select it.
        # RLS should enforce this, but an explicit check is safer.
        check_response = supabase_client.table("job_applications").select("id").eq("id", str(job_id)).eq("user_id", user_id).maybe_single().execute()
        if not check_response.data:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Job application not found or access denied for update")

        # Perform the update
        response = supabase_client.table("job_applications").update(update_data).eq("id", str(job_id)).eq("user_id", user_id).execute()

        if response.data:
            return JobApplicationRead(**response.data[0])
        else:
            # This might happen if RLS prevented update or some other issue
            error_detail = "Failed to update job application."
            if hasattr(response, 'error') and response.error:
                error_detail = f"Failed to update job application: {response.error.message}"
            # It's possible that an update that affects no rows (e.g. ID not found, already caught)
            # or RLS prevents it, might not return data.
            # Re-fetch the record to be sure or check response.count if available and meaningful.
            # For now, if no data after update, assume not found or error.
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=error_detail) # Or 500 if error

    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Database error: {str(e)}")


@router.delete("/{job_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_job_application(
    job_id: UUID,
    current_user: UserResponse = Depends(get_current_user)
):
    if supabase_client is None:
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Supabase client not available")

    user_id = str(current_user.id)

    try:
        # Verify existence and ownership before delete
        check_response = supabase_client.table("job_applications").select("id").eq("id", str(job_id)).eq("user_id", user_id).maybe_single().execute()
        if not check_response.data:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Job application not found or access denied for delete")

        response = supabase_client.table("job_applications").delete().eq("id", str(job_id)).eq("user_id", user_id).execute()

        # Check if delete was successful. Supabase delete usually returns the deleted records.
        # If response.data is empty after a delete where the record was confirmed to exist,
        # it might indicate an RLS issue or other problem.
        # However, if count is available and indicates rows were affected, that's a better check.
        # For now, if no exception, assume success by HTTP 204.
        # If response.data is not empty, it means the delete operation returned the items deleted.
        # If response.data is empty but record existed, it could be an issue.
        # Supabase PostgREST often returns the deleted items. If data is empty, it means nothing was deleted.
        # This was already checked by the select query above.

        # No specific check on response.data needed here if check_response passed and no exception.
        # The HTTP 204 status implies success.

    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Database error: {str(e)}")

    return # FastAPI handles 204 No Content response
